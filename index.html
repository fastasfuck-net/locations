<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>FastAsFuck - Global Network</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800;900&display=swap" rel="stylesheet">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body { 
      height: 100%; 
      font-family: 'Inter', sans-serif; 
      background: radial-gradient(ellipse at center, #1a0f0a 0%, #0a0a0a 100%);
      overflow: hidden; 
      color: #ffffff;
    }
    
    canvas { display: block; }
    
    /* Header Overlay */
    .header-overlay {
      position: absolute;
      top: 0; left: 0; right: 0;
      background: linear-gradient(180deg, rgba(10,10,10,0.95) 0%, rgba(10,10,10,0.7) 50%, rgba(10,10,10,0) 100%);
      z-index: 1000;
      padding: 25px 40px;
      pointer-events: none;
      backdrop-filter: blur(10px);
    }
    
    .header-content { 
      display: flex; 
      justify-content: space-between; 
      align-items: center; 
      max-width: 1400px; 
      margin: 0 auto; 
    }
    
    .header-title { 
      color: #ffffff; 
      font-size: 32px; 
      font-weight: 900; 
      letter-spacing: -0.03em;
      background: linear-gradient(135deg, #ff6b35 0%, #ff8f00 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      text-shadow: 0 0 30px rgba(255, 107, 53, 0.3);
    }
    
    .header-subtitle { 
      color: rgba(255, 255, 255, 0.7); 
      font-size: 14px; 
      font-weight: 400; 
      margin-top: 5px;
      letter-spacing: 0.1em;
    }
    
    /* Legend */
    .legend {
      position: absolute; 
      bottom: 30px; 
      left: 30px;
      background: rgba(20, 20, 20, 0.9); 
      backdrop-filter: blur(30px); 
      border-radius: 20px;
      padding: 25px; 
      z-index: 1000; 
      border: 1px solid rgba(255, 107, 53, 0.2); 
      box-shadow: 0 25px 50px rgba(0,0,0,0.4), 0 0 30px rgba(255, 107, 53, 0.1);
      min-width: 220px;
    }
    
    .legend-title { 
      color: #ffffff; 
      font-size: 18px; 
      font-weight: 700; 
      margin-bottom: 16px;
      background: linear-gradient(135deg, #ff6b35 0%, #ff8f00 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }
    
    .legend-item { 
      display: flex; 
      align-items: center; 
      gap: 14px; 
      margin-bottom: 12px; 
      color: rgba(255, 255, 255, 0.9); 
      font-size: 14px; 
      font-weight: 500;
    }
    
    .legend-dot { 
      width: 14px; 
      height: 14px; 
      border-radius: 50%; 
      border: 2px solid #ffffff; 
      box-shadow: 0 3px 10px rgba(0,0,0,0.4); 
    }
    
    .legend-dot.active { 
      background: #ff6b35; 
      border-color: #ff6b35;
      animation: orangeGlow 2s ease-in-out infinite alternate; 
      box-shadow: 0 0 20px rgba(255, 107, 53, 0.6);
    }
    
    .legend-dot.planned { 
      background: #ff8f00; 
      border-color: #ff8f00;
      box-shadow: 0 0 15px rgba(255, 143, 0, 0.4);
    }
    
    .legend-line { 
      width: 24px; 
      height: 3px; 
      border-radius: 2px; 
      background: linear-gradient(90deg, #ff6b35 0%, #ff8f00 100%);
      box-shadow: 0 0 10px rgba(255, 107, 53, 0.4);
    }
    
    @keyframes orangeGlow { 
      from { box-shadow: 0 0 15px rgba(255, 107, 53, 0.4), 0 3px 10px rgba(0,0,0,0.4); } 
      to { box-shadow: 0 0 25px rgba(255, 107, 53, 0.8), 0 3px 10px rgba(0,0,0,0.4); } 
    }
    
    /* Controls Info */
    .controls-info {
      position: absolute; 
      bottom: 30px; 
      right: 30px;
      background: rgba(20, 20, 20, 0.9); 
      backdrop-filter: blur(30px); 
      border-radius: 20px;
      padding: 20px; 
      z-index: 1000; 
      border: 1px solid rgba(255, 107, 53, 0.2); 
      box-shadow: 0 25px 50px rgba(0,0,0,0.4), 0 0 30px rgba(255, 107, 53, 0.1);
      color: rgba(255, 255, 255, 0.8); 
      font-size: 13px; 
      max-width: 240px;
      pointer-events: auto;
    }
    
    .controls-title {
      font-weight: 700; 
      color: #ffffff; 
      margin-bottom: 12px;
      font-size: 14px;
      background: linear-gradient(135deg, #ff6b35 0%, #ff8f00 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }
    
    .control-item {
      margin-bottom: 8px;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .toggle-button {
      margin-top: 15px; 
      padding: 10px 18px; 
      border: none; 
      border-radius: 12px; 
      background: linear-gradient(135deg, #ff6b35 0%, #ff8f00 100%);
      color: #ffffff; 
      cursor: pointer;
      font-weight: 600;
      font-size: 12px;
      transition: all 0.3s ease;
      box-shadow: 0 4px 15px rgba(255, 107, 53, 0.3);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    .toggle-button:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(255, 107, 53, 0.4);
    }
    
    .toggle-button:active {
      transform: translateY(0);
    }
    
    .toggle-button.disabled {
      background: linear-gradient(135deg, #666 0%, #888 100%);
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
    }
    
    /* Status Indicator */
    .status-indicator {
      display: inline-block;
      width: 8px;
      height: 8px;
      border-radius: 50%;
      margin-right: 6px;
    }
    
    .status-indicator.active {
      background: #ff6b35;
      animation: pulse 2s infinite;
    }
    
    .status-indicator.inactive {
      background: #666;
    }
    
    @keyframes pulse {
      0% { opacity: 1; }
      50% { opacity: 0.5; }
      100% { opacity: 1; }
    }
    
    /* Responsive */
    @media (max-width: 768px) {
      .header-overlay { padding: 20px 25px; }
      .header-title { font-size: 24px; }
      .legend, .controls-info { 
        position: static; 
        margin: 15px; 
        width: calc(100% - 30px); 
        max-width: none;
      }
    }
  </style>
</head>
<body>
  <!-- Header -->
  <div class="header-overlay">
    <div class="header-content">
      <div>
        <div class="header-title">FastAsFuck</div>
        <div class="header-subtitle">GLOBAL NETWORK INFRASTRUCTURE</div>
      </div>
    </div>
  </div>
  
  <!-- Legend -->
  <div class="legend">
    <div class="legend-title">Network Status</div>
    <div class="legend-item">
      <div class="legend-dot active"></div>
      <span>Active Datacenters</span>
    </div>
    <div class="legend-item">
      <div class="legend-dot planned"></div>
      <span>Planned Expansion</span>
    </div>
    <div class="legend-item">
      <div class="legend-line"></div>
      <span>High-Speed Connections</span>
    </div>
  </div>
  
  <!-- Enhanced Controls -->
  <div class="controls-info">
    <div class="controls-title">Interactive Controls</div>
    <div class="control-item">
      <span>üñ±Ô∏è</span>
      <span>Drag to rotate globe</span>
    </div>
    <div class="control-item">
      <span>üîç</span>
      <span>Scroll to zoom in/out</span>
    </div>
    <div class="control-item">
      <span class="status-indicator active" id="rotationStatus"></span>
      <span id="rotationStatusText">Auto-rotation active</span>
    </div>
    <button id="toggleRotation" class="toggle-button">
      Toggle Auto-Rotation
    </button>
  </div>

  <script>
    // Check if Three.js is loaded
    if (typeof THREE === 'undefined') {
      console.error('Three.js library not loaded!');
    }
    
    // FastAsFuck Network locations with enhanced data
    const networkLocations = [
      { city: "Mumbai", country: "India", lat: 19.0815772, lng: 72.8866275, status: "planned", size: 1.2, capacity: "" },
      { city: "Dallas", country: "USA", lat: 32.7762719, lng: -96.7968559, status: "active", size: 1.5, capacity: "" },
      { city: "Los Angeles", country: "USA", lat: 34.0536909, lng: -118.242766, status: "active", size: 1.5, capacity: "" },
      { city: "Amsterdam", country: "Netherlands", lat: 52.3676, lng: 4.9041, status: "active", size: 1.4, capacity: "" },
      { city: "Seoul", country: "South Korea", lat: 37.5666791, lng: 126.9782914, status: "planned", size: 1.4, capacity: "" }
    ];
    
    // Network connections array
    const networkConnections = [];
    
    // Create mesh network between active datacenters only
    for (let i = 0; i < networkLocations.length; i++) {
      for (let j = i + 1; j < networkLocations.length; j++) {
        const loc1 = networkLocations[i];
        const loc2 = networkLocations[j];

        if (loc1.status === 'active' && loc2.status === 'active') {
          networkConnections.push({
            startLat: loc1.lat,
            startLng: loc1.lng,
            endLat: loc2.lat,
            endLng: loc2.lng,
            color: '#ff6b35',
            opacity: 0.8,
            altitude: 0.3 + Math.random() * 0.2,
            isActive: true
          });
        }
      }
    }

    
    var renderer, camera, scene, controls, globe;
    let mouseX = 0;
    let mouseY = 0;
    let autoRotate = true;
    let isDragging = false;
    let windowHalfX = window.innerWidth / 2;
    let windowHalfY = window.innerHeight / 2;
    let labelGroup; // Group for labels that rotate with globe
    
    // Wait for the page to load before initializing
    window.addEventListener('load', function() {
      if (typeof THREE !== 'undefined') {
        console.log('Three.js loaded successfully');
        init();
        initGlobe();
        onWindowResize();
        animate();
      } else {
        console.error('Three.js failed to load');
      }
    });
    
    // Initialize core ThreeJS elements
    function init() {
      // Initialize renderer with enhanced settings
      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setClearColor(0x0a0a0a, 1);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      document.body.appendChild(renderer.domElement);
      
      // Initialize scene with enhanced lighting
      scene = new THREE.Scene();
      scene.add(new THREE.AmbientLight(0x808080, 0.6)); // Much brighter ambient light
      scene.background = new THREE.Color(0x0a0a0a);
      // Initialize camera
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0, 0, 300);
      // Enhanced lighting setup with orange theme
      const dLight = new THREE.DirectionalLight(0xffffff, 1.0); // Much brighter main light
      dLight.position.set(-800, 2000, 400);
      dLight.castShadow = true;
      camera.add(dLight);
      
      const orangeLight = new THREE.DirectionalLight(0xff6b35, 0.3);
      orangeLight.position.set(200, -500, -200);
      camera.add(orangeLight);
      
      const accentLight = new THREE.PointLight(0xff8f00, 0.4);
      accentLight.position.set(-200, 500, 200);
      camera.add(accentLight);
      
      // Add additional fill light to brighten the globe
      const fillLight = new THREE.DirectionalLight(0xffffff, 0.5);
      fillLight.position.set(800, -2000, -400);
      camera.add(fillLight);
      
      scene.add(camera);
      
      // Add atmospheric fog with orange tint
      scene.fog = new THREE.Fog(0x1a0f0a, 400, 2000);
      // Simple mouse controls
      initControls();
      window.addEventListener("resize", onWindowResize, false);
      document.addEventListener("mousemove", onMouseMove);
    }
    
    function initControls() {
      let previousMousePosition = { x: 0, y: 0 };
      
      document.addEventListener('mousedown', (e) => {
        isDragging = true;
        previousMousePosition.x = e.clientX;
        previousMousePosition.y = e.clientY;
        // Disable auto-rotation when user starts dragging
        autoRotate = false;
        updateRotationStatus();
      });
      
      document.addEventListener('mousemove', (e) => {
        if (isDragging && globe) {
          const deltaMove = {
            x: e.clientX - previousMousePosition.x,
            y: e.clientY - previousMousePosition.y
          };
          globe.rotation.y += deltaMove.x * 0.005;
          globe.rotation.x += deltaMove.y * 0.005;
          
          // Sync label group rotation with globe
          labelGroup.rotation.y = globe.rotation.y;
          labelGroup.rotation.x = globe.rotation.x;
          
          previousMousePosition.x = e.clientX;
          previousMousePosition.y = e.clientY;
        }
      });
      
      document.addEventListener('mouseup', () => {
        isDragging = false;
      });
      
      // Enhanced zoom with smoother controls
      document.addEventListener('wheel', (e) => {
        e.preventDefault();
        const zoomSpeed = 0.1;
        camera.position.z += e.deltaY * zoomSpeed;
        camera.position.z = Math.max(120, Math.min(600, camera.position.z));
      });
    }
    
    // Initialize Globe
    function initGlobe() {
      // Create basic globe geometry
      const globeGeometry = new THREE.SphereGeometry(100, 64, 32);
      
      // Load earth texture
      const textureLoader = new THREE.TextureLoader();
      const earthTexture = textureLoader.load('https://unpkg.com/three-globe/example/img/earth-blue-marble.jpg');
      
      const globeMaterial = new THREE.MeshPhongMaterial({
        map: earthTexture,
        color: new THREE.Color(0xffffff), // Bright white to show true colors
        emissive: new THREE.Color(0x2a1810), // Warm orange emissive glow
        emissiveIntensity: 0.15,
        shininess: 60,
        transparent: false,
        opacity: 1.0
      });
      globe = new THREE.Mesh(globeGeometry, globeMaterial);
      scene.add(globe);
      
      // Create a group for labels that rotates with the globe
      labelGroup = new THREE.Group();
      scene.add(labelGroup);
      
      // Add enhanced orange atmosphere glow
      const atmosphereGeometry = new THREE.SphereGeometry(106, 64, 32);
      const atmosphereMaterial = new THREE.ShaderMaterial({
        transparent: true,
        side: THREE.BackSide,
        vertexShader: `
          varying vec3 vNormal;
          void main() {
            vNormal = normalize(normalMatrix * normal);
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
          }
        `,
        fragmentShader: `
          varying vec3 vNormal;
          void main() {
            float intensity = pow(0.6 - dot(vNormal, vec3(0.0, 0.0, 1.0)), 1.5);
            vec3 orangeGlow = vec3(1.0, 0.42, 0.21); // Orange color
            gl_FragColor = vec4(orangeGlow, 0.4) * intensity; // Reduced opacity
          }
        `
      });
      
      const atmosphere = new THREE.Mesh(atmosphereGeometry, atmosphereMaterial);
      scene.add(atmosphere);
      // Add network locations after a delay
      setTimeout(() => {
        addNetworkLocations();
        addNetworkConnections();
      }, 1000);
    }
    
    // Convert lat/lng to 3D position
    function latLngToVector3(lat, lng, radius) {
      const phi = (90 - lat) * (Math.PI / 180);
      const theta = (lng + 180) * (Math.PI / 180);
      
      const x = -(radius * Math.sin(phi) * Math.cos(theta));
      const z = (radius * Math.sin(phi) * Math.sin(theta));
      const y = (radius * Math.cos(phi));
      
      return new THREE.Vector3(x, y, z);
    }
    
    function addNetworkLocations() {
      networkLocations.forEach((location, index) => {
        const position = latLngToVector3(location.lat, location.lng, 102);
        
        // Create enhanced location marker with orange theme
        const markerGeometry = new THREE.SphereGeometry(2.5 * location.size, 20, 20);
        const markerMaterial = new THREE.MeshPhongMaterial({
          color: location.status === 'active' ? 0xff6b35 : 0xff8f00,
          transparent: true,
          opacity: 0.95,
          emissive: location.status === 'active' ? 0xff6b35 : 0xff8f00,
          emissiveIntensity: 0.3,
          shininess: 100
        });
        
        const marker = new THREE.Mesh(markerGeometry, markerMaterial);
        marker.position.copy(position);
        globe.add(marker);
        
        // Create enhanced glow effect
        const glowGeometry = new THREE.SphereGeometry(4 * location.size, 20, 20);
        const glowMaterial = new THREE.MeshBasicMaterial({
          color: location.status === 'active' ? 0xff6b35 : 0xff8f00,
          transparent: true,
          opacity: 0.2
        });
        
        const glow = new THREE.Mesh(glowGeometry, glowMaterial);
        glow.position.copy(position);
        globe.add(glow);
        
        // Add pulsing animation for active locations
        if (location.status === 'active') {
          marker.userData = { 
            type: 'activeMarker', 
            pulsePhase: Math.random() * Math.PI * 2,
            originalScale: marker.scale.x 
          };
          glow.userData = { 
            type: 'activeGlow', 
            pulsePhase: Math.random() * Math.PI * 2,
            originalOpacity: glow.material.opacity 
          };
        }
        
        // Add enhanced text label with capacity info
        const canvas = document.createElement('canvas');
        canvas.width = 320;
        canvas.height = 80;
        const ctx = canvas.getContext('2d');
        
        ctx.fillStyle = '#ffffff';
        ctx.font = 'bold 22px Inter, sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText(location.city, 160, 25);
        
        ctx.font = '14px Inter, sans-serif';
        ctx.fillStyle = location.status === 'active' ? '#ff6b35' : '#ff8f00';
        ctx.fillText(`${location.status.toUpperCase()} ‚Ä¢ ${location.capacity}`, 160, 45);
        
        ctx.font = '12px Inter, sans-serif';
        ctx.fillStyle = '#cccccc';
        ctx.fillText(location.country, 160, 62);
        
        const labelTexture = new THREE.CanvasTexture(canvas);
        const labelMaterial = new THREE.SpriteMaterial({ 
          map: labelTexture,
          transparent: true,
          opacity: 0.9
        });
        
        const label = new THREE.Sprite(labelMaterial);
        
        // Position label above the marker
        const labelPosition = position.clone();
        labelPosition.normalize().multiplyScalar(115); // Higher radius for labels
        label.position.copy(labelPosition);
        label.scale.set(25, 6, 1);
        
        // Store data for animation and sync with globe rotation
        label.userData = {
          type: 'locationLabel',
          location: location,
          basePosition: labelPosition.clone(),
          pulsePhase: Math.random() * Math.PI * 2,
          markerPosition: position
        };
        
        labelGroup.add(label);
      });
    }
    
    function addNetworkConnections() {
  networkConnections.forEach(connection => {
    const startPos = latLngToVector3(connection.startLat, connection.startLng, 100);
    const endPos = latLngToVector3(connection.endLat, connection.endLng, 100);

    // Berechne den Mittelpunkt direkt zwischen Start und Ende
    const midPoint = new THREE.Vector3().addVectors(startPos, endPos).multiplyScalar(0.4);

    // F√ºge H√∂he hinzu: leicht √ºber die Kugel hinaus
    midPoint.normalize().multiplyScalar(100 + connection.altitude * 100);

    const curve = new THREE.QuadraticBezierCurve3(startPos, midPoint, endPos);
    const points = curve.getPoints(330);

    const arcGeometry = new THREE.BufferGeometry().setFromPoints(points);
    const arcMaterial = new THREE.LineBasicMaterial({ 
      color: connection.color,
      transparent: true,
      opacity: connection.opacity,
      linewidth: 3
    });

    const arc = new THREE.Line(arcGeometry, arcMaterial);
    globe.add(arc);

    // Partikel f√ºr aktive Verbindungen
    if (connection.isActive) {
      const particleCount = 3;
      for (let i = 0; i < particleCount; i++) {
        const particleGeometry = new THREE.SphereGeometry(0.8, 12, 12);
        const particleMaterial = new THREE.MeshBasicMaterial({ 
          color: 0xff6b35,
          transparent: true,
          opacity: 0.9,
          emissive: 0xff6b35,
          emissiveIntensity: 0.3
        });

        const particle = new THREE.Mesh(particleGeometry, particleMaterial);
        particle.userData = {
          type: 'networkParticle',
          curve: curve,
          progress: i / particleCount,
          speed: 0.005 + Math.random() * 0.005
        };

        globe.add(particle);
      }
    }
  });
}

    
    function onMouseMove(event) {
      mouseX = event.clientX - windowHalfX;
      mouseY = event.clientY - windowHalfY;
    }
    
    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      windowHalfX = window.innerWidth / 2;
      windowHalfY = window.innerHeight / 2;
      renderer.setSize(window.innerWidth, window.innerHeight);
    }
    
    function animate() {
      requestAnimationFrame(animate);
      
      // Auto rotation with smooth movement
      if (globe && autoRotate && !isDragging) {
        globe.rotation.y += 0.003;
        // Sync label group rotation with globe
        labelGroup.rotation.y = globe.rotation.y;
        labelGroup.rotation.x = globe.rotation.x;
      }
      
      // Animate pulsing markers and particles
      const time = Date.now() * 0.001;
      
      globe.children.forEach(child => {
        if (child.userData.type === 'activeMarker') {
          const pulse = Math.sin(time * 2 + child.userData.pulsePhase) * 0.5 + 0.5;
          child.scale.setScalar(child.userData.originalScale * (1 + pulse * 0.3));
        }
        
        if (child.userData.type === 'activeGlow') {
          const pulse = Math.sin(time * 2 + child.userData.pulsePhase) * 0.5 + 0.5;
          child.material.opacity = child.userData.originalOpacity * (0.3 + pulse * 0.7);
        }
        
        if (child.userData.type === 'networkParticle') {
          child.userData.progress += child.userData.speed;
          if (child.userData.progress > 1) child.userData.progress = 0;
          
          const point = child.userData.curve.getPoint(child.userData.progress);
          child.position.copy(point);
          
          // Fade in/out at ends
          const fadeDistance = 0.1;
          let opacity = 1;
          if (child.userData.progress < fadeDistance) {
            opacity = child.userData.progress / fadeDistance;
          } else if (child.userData.progress > 1 - fadeDistance) {
            opacity = (1 - child.userData.progress) / fadeDistance;
          }
          child.material.opacity = opacity * 0.8;
        }
      });
      
      // Animate labels
      labelGroup.children.forEach(label => {
        if (label.userData && label.userData.type === 'locationLabel') {
          // Small floating animation
          const float = Math.sin(time + label.userData.pulsePhase) * 0.5;
          label.position.copy(label.userData.basePosition);
          const floatOffset = label.userData.basePosition.clone().normalize().multiplyScalar(float);
          label.position.add(floatOffset);
          
          // Pulse active location labels
          if (label.userData.location.status === 'active') {
            const pulse = Math.sin(time * 1.5 + label.userData.pulsePhase) * 0.2 + 0.8;
            label.material.opacity = pulse;
          } else {
            label.material.opacity = 0.7;
          }
        }
      });
      
      // Subtle camera movement
      camera.position.x += (mouseX * 0.1 - camera.position.x) * 0.002;
      camera.position.y += (-mouseY * 0.1 - camera.position.y) * 0.002;
      camera.lookAt(scene.position);
      
      renderer.render(scene, camera);
    }

    // Enhanced auto-rotation toggle with visual feedback
    function updateRotationStatus() {
      const statusIndicator = document.getElementById('rotationStatus');
      const statusText = document.getElementById('rotationStatusText');
      const toggleButton = document.getElementById('toggleRotation');
      
      if (autoRotate) {
        statusIndicator.className = 'status-indicator active';
        statusText.textContent = 'Auto-rotation active';
        toggleButton.textContent = 'Disable Auto-Rotation';
        toggleButton.className = 'toggle-button';
      } else {
        statusIndicator.className = 'status-indicator inactive';
        statusText.textContent = 'Manual control mode';
        toggleButton.textContent = 'Enable Auto-Rotation';
        toggleButton.className = 'toggle-button disabled';
      }
    }

    // Wait for DOM to be ready before adding event listeners
    document.addEventListener('DOMContentLoaded', function() {
      const toggleButton = document.getElementById('toggleRotation');
      if (toggleButton) {
        toggleButton.addEventListener('click', () => {
          autoRotate = !autoRotate;
          updateRotationStatus();
        });
        
        // Initialize status display
        updateRotationStatus();
      }
    });

  </script>
</body>

</html>
